// solution 1
const findMin = (nums) => {
  const sorted = nums.sort((a, b) => a - b)
  return sorted[0]
}

console.log(findMin([3, 4, 5, 1, 2]))

// solution 2

const findMin2 = (nums) => {
  return Math.min(...nums)
}

console.log(findMin([3, 4, 5, 1, 2]))

// Предположим, что массив длины n, отсортированный в порядке возрастания, вращается между 1и nраз. Например, массив nums = [0,1,2,4,5,6,7]может выглядеть следующим образом:

// [4,5,6,7,0,1,2]если бы он был повернут 4раз.
// [0,1,2,4,5,6,7]если бы он был повернут 7раз.
// Обратите внимание, что при вращении массива [a[0], a[1], a[2], ..., a[n-1]]1 раз получается массив [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

// Учитывая отсортированный повернутый массив numsуникальных элементов , верните минимальный элемент этого массива .

// Вы должны написать алгоритм, который работает в O(log n) time.
